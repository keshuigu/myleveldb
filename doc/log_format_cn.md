# leveldb的日志格式

日志文件内容是一系列 32KB 块。唯一的例外是文件的尾部可能包含不完全的块。

每个块由一系列记录组成：

```
block := record* trailer?
record :=
  checksum: uint32     // type and data[]的crc32c校验和，小端序
  length: uint16       // 小端序
  type: uint8          // FULL, FIRST, MIDDLE, LAST 之一
  data: uint8[length]
```

记录永远不会在块的最后六个字节内开始（因为它放不下）。此处的任何剩余字节都形成尾部，尾部必须完全由零字节组成，并且必须由读取器跳过。

除此之外：如果当前块中只剩下7个字节，并且添加了一个新的非零长度记录，则写入程序必须发出一个FIRST记录（包含0个字节的用户数据）来填充块的后七个字节，然后在后续块中发出所有用户数据。

未来可能会添加更多类型。一些读取器可能会跳过他们无法识别的记录类型，其他读取器可能会报告某些数据被跳过。

```
FULL == 1
FIRST == 2
MIDDLE == 3
LAST == 4
```

FULL记录包含整个用户记录的内容。

FIRST、MIDDLE和LAST是用于已拆分为多个片段的用户记录的类型（通常是因为块边界）。FIRST是用户记录的第一个片段的类型，LAST是用户记录最后一个片段的类别，MIDDLE是用户记录所有内部片段的类别。

示例：考虑一系列用户记录：

```
A: length 1000
B: length 97270
C: length 8000
```

**A**将作为FULL记录存储在第一个块中

**B**将被分成三个片段：第一个片段占据第一个块的其余部分，第二个片段占据第二个块的整个部分，第三个片段占据了第三个块的前一部分。这将在第三个块中留下六个空闲字节，该块将作为尾部保留为空。计算过程：

1. 32KB -> 32768B
2. 第一块：**A** FULL 7 + 1000 B + **B** FIRST 7 + 31754 B
3. 第二块：**B** MIDDLE 7+ 32761 B
4. 第三块：**B** LAST 7+ 32755 B , 剩余六字节


**C**将作为FULL记录存储在第四个块中。

----

## 与记录格式相比的优点

1. 我们不需要任何启发式方法来重新同步：只需转到下一个块边界并进行扫描即可。如果出现损坏就跳过下一个块。另外有一点优势：如果一个日志文件的部分内容作为记录嵌入到另一日志文件中时，这些内容不会造成混乱。
2. 便于在近似边界进行拆分（例如，对于mapreduce）：找到下一个块边界并跳过记录，直到找到FULL或FIRST记录。
3. 对于大型记录，不需要额外的缓冲。

## 与记录格式相比的缺点

1. 没有微小记录的封装。但这个问题可以通过添加新的记录类型来解决，因此这是当前实现的一个缺点，而不一定是格式的缺点。
2. 无压缩。同样，这可以通过添加新的记录类型来解决。